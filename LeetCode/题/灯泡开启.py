'''初始时有 n 个灯泡关闭。 第 1 轮，你打开所有的灯泡。 第 2 轮，每两个灯泡你关闭一次。 第 3 轮，
每三个灯泡切换一次开关（如果关闭则开启，如果开启则关闭）。第 i 轮，每 i 个灯泡切换一次开关。 对于第 n 轮，
你只切换最后一个灯泡的开关。 找出 n 轮后有多少个亮着的灯泡。

示例:

输入: 3
输出: 1 
解释: 
初始时, 灯泡状态 [关闭, 关闭, 关闭].
第一轮后, 灯泡状态 [开启, 开启, 开启].
第二轮后, 灯泡状态 [开启, 关闭, 开启].
第三轮后, 灯泡状态 [开启, 关闭, 关闭]. 

你应该返回 1，因为只有一个灯泡还亮着。'''


def bulbSwitch(n):
    """
    :type n: int
    :rtype: int
        """
    # 0表示关闭， 1表示开启
    # 初始化

    # start = [0 for i in range(n)]
    # start.append(0)
    # for i in range(1, len(start)):
    #     n = 1
    #     for j in range(i * n, len(start)):
    #         if j % i == 0:
    #             if start[j] == 0:
    #                 start[j] = 1
    #             else:
    #                 start[j] = 0
    #     if i * (n + 1) <= len(start):
    #         n += 1
    # return start[1:].count(1)
    return int(n ** 0.5)
    '''注意到，对第K个灯泡(K从0到n-1)，在第i轮，当且仅当(K + 1) % i = 0时，灯泡的状态会翻转。
    在第一轮，所有灯泡都被点亮。灯泡K在n轮后依然是点亮的，则灯泡K在2到n轮间被翻转了偶数次。
    等价于，在[2, n]中有偶数个轮次满足(K + 1) % i = 0。
    等价于，K + 1在[2, n]间有偶数个因子。
    等价于，K + 1在[2, K]间有奇数个因子。(K+1本身已被除去）
    现在注意到，如果(K + 1) / j = i是整数，则i, j都是K + 1的因子，因子数量应该是偶数个。但K + 1有奇数个因子，那么就存在一个数i, (K + 1) / j = i, 并且i = j。换句话说，K+1自身就是一个完全平方数。
    
    结论：亮灯数等于[1, n]内的完全平方数个数，即：
    '''
a = 9999
result = bulbSwitch(a)
print(result)